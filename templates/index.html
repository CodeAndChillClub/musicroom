{% extends "base.html" %}
{% block head %}
  <title>Music Room</title>
  <!-- Handlebars -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/handlebars.js/4.0.10/handlebars.min.js"></script>
  <!-- YouTube Player API -->
  <script src="http://www.youtube.com/player_api"></script>
{% endblock %}
{% block body %}
  <div class="ui inverted vertical center aligned segment head"><div class="head-container">
    <div class="ui text container">
      <h1 class="ui inverted header">Music Room</h1>
      <h3>Listen to music together with your friends.</h3>
    </div>
    <hr/>
    <div class="ui player">
      <div class="fifteen wide column">
        <h2 class="current-title" style="display:none"></h2>
        <div id="yt-player" style="display:none"></div>
      </div>
    </div>
    <div class="ui text container">
      <a style="color:white; font-size:150%" href="javascript:skipSong()"><i class="lerge forward icon"></i></a>
    </div>
  </div></div>
  <div class="ui vertical aligned segment head"><div class="head-container">
    <h1>Add a Song</h1>
    <div class="ui message" style="display:none">
      <p></p>
    </div>
    <form class="ui form" id="add-song-form" method="post" action="/api/submit" onsubmit="submitSongUrl(event)">
      <div class="field">
        <label>YouTube URL</label>
        <input type="text" name="url" placeholder="https://www.youtube.com/watch?v=e8T_fzSY34s">
        <input type="text" name="room" hidden value="{{ room.name }}">
      </div>
      <button class="ui button" type="submit">Submit</button>
    </form>
  </div></div>
  <div class="ui inverted vertical aligned segment head"><div class="head-container">
    <hr/>
    <div class="ui grid">
      <div class="row">
        <div class="eight wide column">
          <h1>Queue</h1>
          <!-- Queue List -->
          <div class="ui inverted relaxed divided list" id="queue">
            {% raw %}
            <script id="handlebars:queue-item" type="text/x-handlebars-template">
              <div class="item">
                <i class="large {{ icon }} middle aligned icon"></i>
                <div class="content">
                  <a onclick="onQueueItemClick.apply(this)" class="header">{{ title }}</a>
                  <div class="description">{{ url }}</div>
                </div>
              </div>
            </script>
            {% endraw %}
          </div>
        </div>
        <div class="eight wide column">
          <h1>History</h1>
          <div class="ui inverted relaxed divided list" id="history">
          </div>
        </div>
      </div>
    </div>
  </div></div>
  <div class="ui text vertical center aligned segment">
    <p>Copyright &copy; Niklas Rosenstein 2017</p>
    <p><i class="github icon"></i><a href="https://github.com/NiklasRosenstein/musicroom">NiklasRosenstein/musicroom</a></p>
  </div>


  <script>
    // Queue-item template.
    var queueItemTemplate = Handlebars.compile(document.getElementById('handlebars:queue-item').innerHTML)
    function renderQueueItem(song) {
      let icon = 'music'
      if (song.classtype == 'YtSong') icon = 'youtube'
      return $(queueItemTemplate({
        title: song.title,
        url: song.url,
        icon: icon
      })).data(song)
    }

    function onQueueItemClick() {
      // If an item in the history is clicked, we queue it again.
      let item = this.parentNode.parentNode;
      if (item.parentNode.id == 'history') {
        let song = $(item).data();
        let form = $('#add-song-form')
        $('input[name="url"]', form)[0].value = song.url
        form.submit()
      }
    }

    // Load the queued items and room history.
    d3.json("/api/queue?room={{room.name}}", function (data) {
      console.log('QUEUE:', data.data)
      for (let i = 0; i < data.data.length; ++i) {
        $('#queue').append(renderQueueItem(data.data[i]))
      }
    })
    d3.json("/api/history?room={{room.name}}", function (data) {
      console.log('history:', data.data)
      for (let i = 0; i < data.data.length; ++i) {
        $('#history').append(renderQueueItem(data.data[i]))
      }
    })

    // Helper function to retrieve the song that is currently being played.
    function getCurrentSong(callback) {
      return d3.json("/api/current-song?room={{room.name}}", function (data) {
        callback(data.data, data.status, data.message)
      })
    }

    // Helper function to send a post request.
    function post(url, form, callback) {
      let data = $.param(form);
      console.log(data)
      return d3.request(url)
        .header("Content-type", "application/x-www-form-urlencoded")
        .on("error", function(progress) { if (callback) callback(progress.target, progress) })
        .on("load", function(xhr) { if (callback) callback(xhr) })
        .send("POST", data)
    }

    // Callback for the "Skip" button.
    function skipSong() {
      post("/api/skip-song?room={{room.name}}", {}, function () {
        updateCurrentSong()
      })
    }

    // Callback for the "Add a Song" form.
    function submitSongUrl(event) {
      event.preventDefault()
      let form = {}
      d3.selectAll("#add-song-form input").each(function (d) {
        form[this.name] = this.value
      })
      post("/api/submit", form, function(xhr, progress) {
        let data = JSON.parse(xhr.responseText)
        let song = data.data;

        /* Remove all existing classes. */
        let message = d3.select('.head .ui.message')
          .classed('positive', false)
          .classed('negative', false)
          .classed('info', false)

        /* Insert the message with the right class. */
        $(message.node()).show()
        if (data.status == 200) {
          if (song.already_in_queue)
            message.classed('info', true).text('The song is already in the queue: ' + song.title)
          else
            message.classed('positive', true).text('The song was added to the queue.')
        }
        else {
          message.classed('negative', true).text(data.message)
        }

        if (data.status == 200 && !song.already_in_queue) {
          $('#queue').append(renderQueueItem(song))
        }
      })
    }

    // Sets the title above the Player.
    function setPlayerTitle(title) {
      let h2 = document.querySelector('.head .player .current-title')
      if (title) {
        h2.innerText = title
        $(h2).show()
      }
      else
        $(h2).hide()
    }

    /* YouTube */
    let song = null
    let yt_delayedPlay = null
    let yt_player = null

    function youTubePlay() {
      youTubeShow(true)

      if (!YT.Player) {
        /* Play as soon as the YT API is ready. */
        yt_delayedPlay = song
        return
      }

      if (!yt_player) {
        yt_player = new YT.Player('yt-player', {
          width: '640',
          height: '390',
          videoId: song.video_id,
          events: {
            onReady: onYouTubePlayerReady,
            onStateChange: onYoutTubePlayerStateChange
          }
        })
      }
      else {
        yt_player.loadVideoById(song.video_id)
      }

    }

    function youTubeShow(show) {
      let el = $('#yt-player')
      if (show) el.show()
      else el.hide()
    }

    function onYouTubePlayerReady() {
      // Start playing the video
      yt_player.playVideo()
      yt_player.seekTo(song.time_passed)
    }

    function onYoutTubePlayerStateChange () {
      let state = yt_player.getPlayerState()
      if (state == 0) { // Ended
        updateCurrentSong()
      }
      console.log('YT Player: state changed', state)
    }

    function onYouTubePlayerAPIReady() {
      if (yt_delayedPlay) {
        youTubePlay()
        yt_delayedPlay = null
      }
    }


    function updateCurrentSong() {
      getCurrentSong(function (new_song) {
        if (new_song) {
          /* If the song is going to end soon, we update again, soon. */
          let remaining = new_song.duration - new_song.time_passed
          if (remaining < 5) {
            console.log("Song is about to end soon. Retrying update in", remaining + 0.5, "seconds.")
            setTimeout(updateCurrentSong, (remaining + 0.5) * 1000)
          }

          /* If it's the same song, there's no need to update. */
          if (song && new_song.id == song.id) {
            console.log("Got the same song. Skipping player update")
            return
          }

          song = new_song
          setPlayerTitle(song.title)
          if (song.classtype == 'YtSong') {
            youTubePlay()
          }
        }
        else {
          if (yt_player) yt_player.stopVideo()
          setPlayerTitle(null)
          youTubeShow(false)

          console.log("We really don't have anything to play. Check again in 2s")
          setTimeout(updateCurrentSong, 2000)
        }
      })
    }

    updateCurrentSong()
  </script>
  {% endblock %}
